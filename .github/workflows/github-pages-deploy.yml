name: Deploy in Github Pages

on: 
  push:
    paths:
    - 'published/**'
    - 'index.css'
    - 'common/**/*.md'

permissions: 
  contents: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 2
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm install

      - name: Get modified slide directories
        run: |
          # Get the list of modified files
          modified_files=$(git show ${{ github.sha }} --name-only)
          echo "Modified files: $modified_files"

          # Check if index.css is modified
          if echo "$modified_files" | grep -q "^index.css$"; then
            echo "index_css_modified=true" >> $GITHUB_ENV
          else
            echo "index_css_modified=false" >> $GITHUB_ENV
          fi

          # Check if any markdown files in the common directory are modified
          if echo "$modified_files" | grep -q "^common/.*\.md$"; then
            echo "common_md_modified=true" >> $GITHUB_ENV
          else
            echo "common_md_modified=false" >> $GITHUB_ENV
          fi

          # Get modified published directories
          published_dirs=$(echo "$modified_files" | grep "^published/.*/.*\.\(md\|vue\|ts\|tsx\|js\|jsx\|html\|css\)$" | xargs -I {} dirname {} | sort | uniq)
          echo "Modified slide directories: $published_dirs"

          # Temporary file to store directories
          temp_file=$(mktemp)

          # Loop through modified files and find the closest parent directory with a markdown file
          for dir in $published_dirs; do
            while [ "$dir" != "." ]; do
              if ls "$dir"/*.md >/dev/null 2>&1; then
                echo "$dir" >> "$temp_file"
                break
              fi
              dir=$(dirname "$dir")
            done
          done

          echo "Directories with markdown files: $(cat $temp_file)"

          # Remove duplicates and store the result in modified_dirs
          modified_dirs=$(sort "$temp_file" | uniq | tr '\n' ' ')

          # Clean up temporary file
          rm "$temp_file"

          echo "Unique modified directories: $modified_dirs"

          # Output the modified directories to be used as an environment variable
          echo "modified_dirs=${modified_dirs}" >> $GITHUB_ENV

      - name: Create build directory
        run: |
            mkdir -p build
            if [ "${{ env.common_md_modified }}" = "true" ]; then
              # Create folders for all slide projects if common markdown modified
              find published -type f -name "slides.md" | while read -r file; do
                dir=$(dirname "$file")
                mkdir -p build/$(echo "$dir" | awk -F'published/' '{print $2}')
              done
            else
              # Only create folders for modified directories
              for dir in ${{ env.modified_dirs }}; do
                mkdir -p build/$(echo "$dir" | awk -F'published/' '{print $2}')
              done
            fi

      - name: Build modified slides
        if: env.modified_dirs != '' || env.common_md_modified == 'true'
        run: |
          if [ "${{ env.common_md_modified }}" = "true" ]; then
            # Rebuild all slides if common markdown modified
            find published -type f -name "slides.md" | while read -r file; do
              dir=$(dirname "$file")
              npm run build -- --base /lectures/$(echo "$dir" | awk -F'published/' '{print $2}')/ $file
              mv $dir/dist/* build/$(echo "$dir" | awk -F'published/' '{print $2}') -v
            done
          else
            # Only build modified slides
            for dir in ${{ env.modified_dirs }}; do
              npm run build -- --base /lectures/$(echo "$dir" | awk -F'published/' '{print $2}')/ $dir/slides.md
              mv $dir/dist/* build/$(echo "$dir" | awk -F'published/' '{print $2}') -v
            done
          fi

      - name: Build index.html
        if: env.index_css_modified == 'true' || env.modified_dirs != '' || env.common_md_modified == 'true'
        run: |
          if [[ -f index.css ]]; then
            mv index.css build/index.css
          fi

          # Temporary file to store links
          temp_links_file=$(mktemp)

          # Find all directories containing a slides.md file and extract their relative paths
          find published -type f -name "slides.md" | while read -r file; do
            dir=$(dirname "$file")
            slide_path=$(echo "$dir" | sed 's|published/||')
            echo "$slide_path" >> "$temp_links_file"
          done

          # Sort the links lexicographically and remove duplicates
          sorted_links=$(sort "$temp_links_file" | uniq)

          echo "Sorted links: $sorted_links"

          # Begin writing the new index.html in the lectures directory
          {
            echo '<!DOCTYPE html>'
            echo '<html lang="en">'
            echo '<head>'
            echo '  <meta charset="UTF-8">'
            echo '  <meta name="viewport" content="width=device-width, initial-scale=1.0">'
            echo '  <link rel="stylesheet" href="./index.css">'
            echo '  <title>Lectures</title>'
            echo '</head>'
            echo '<body class="container">'
            echo '  <h1>Lecture Presentations</h1>'
            echo '  <ul>'

            # Add sorted links to index.html
            for link in $sorted_links; do
              echo "    <li><a href=\"$link/\">$link</a></li>"
            done

            echo '  </ul>'
            echo '</body>'
            echo '</html>'
          } > build/index.html

          # Clean up temporary files
          rm "$temp_links_file"

      - name: Generate explorer pages from published into build
        shell: bash
        run: |
          generate_explorer() {
            published_dir="$1"
            # Remove the "published/" prefix to compute the relative path.
            relative_dir="${published_dir#published/}"
            if [ "$relative_dir" = "$published_dir" ]; then
              relative_dir=""
            fi

            # Determine the corresponding build directory.
            if [ -z "$relative_dir" ]; then
              build_dir="build"
            else
              build_dir="build/$relative_dir"
            fi
            mkdir -p "$build_dir"

            # Calculate depth (number of subdirectories) for proper CSS linking.
            if [ -z "$relative_dir" ]; then
              depth=0
            else
              depth=$(echo "$relative_dir" | awk -F'/' '{print NF}')
            fi
            relative_css=""
            for ((i=0; i<depth; i++)); do
              relative_css="../$relative_css"
            done

            # Set a display name.
            if [ -z "$relative_dir" ]; then
              display_path="Home"
            else
              display_path="$relative_dir"
            fi

            # If this published directory has a slides.md file, stop here.
            if [ -f "$published_dir/slides.md" ]; then
              return
            fi

            output_file="$build_dir/explorer.html"

            # Build the explorer.html using echo commands.
            echo "<!DOCTYPE html>" > "$output_file"
            echo "<html lang=\"en\">" >> "$output_file"
            echo "<head>" >> "$output_file"
            echo "  <meta charset=\"UTF-8\">" >> "$output_file"
            echo "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">" >> "$output_file"
            echo "  <link rel=\"stylesheet\" href=\"${relative_css}index.css\">" >> "$output_file"
            echo "  <title>File Explorer - ${display_path}</title>" >> "$output_file"
            echo "  <style>" >> "$output_file"
            echo "    body { font-family: sans-serif; margin: 20px; }" >> "$output_file"
            echo "    ul { list-style-type: none; padding: 0; }" >> "$output_file"
            echo "    li { padding: 5px; margin: 2px 0; }" >> "$output_file"
            echo "    a { text-decoration: none; color: #0366d6; }" >> "$output_file"
            echo "    a:hover { text-decoration: underline; }" >> "$output_file"
            echo "  </style>" >> "$output_file"
            echo "</head>" >> "$output_file"
            echo "<body>" >> "$output_file"
            echo "  <h1>File Explorer - ${display_path}</h1>" >> "$output_file"

            # Add an "Up" link if not at the root.
            if [ "$published_dir" != "published" ]; then
              echo "  <p><a href=\"../explorer.html\">Up</a></p>" >> "$output_file"
            fi

            echo "  <ul>" >> "$output_file"

            # Process each immediate entry in the published directory.
            for entry in "$published_dir"/*; do
              if [ -d "$entry" ]; then
                name=$(basename "$entry")
                # If the child directory has a slides.md file, link directly to it;
                # otherwise, link to its explorer page.
                if [ -f "$entry/slides.md" ]; then
                  echo "    <li>[DIR] <a href=\"$name/slides.md\">$name</a></li>" >> "$output_file"
                else
                  echo "    <li>[DIR] <a href=\"$name/explorer.html\">$name</a></li>" >> "$output_file"
                fi
              elif [ -f "$entry" ]; then
                file=$(basename "$entry")
                # Skip explorer.html so as not to list it.
                if [ "$file" != "explorer.html" ]; then
                  echo "    <li>[FILE] <a href=\"$file\">$file</a></li>" >> "$output_file"
                fi
              fi
            done

            echo "  </ul>" >> "$output_file"
            echo "</body>" >> "$output_file"
            echo "</html>" >> "$output_file"
          }

          export -f generate_explorer

          # Recursively process every directory under published (deepest first).
          find published -type d | sort -r | while read -r dir; do
            generate_explorer "$dir"
          done
  

      - name: Deploy slides 🚀
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          branch: gh-pages # The branch the action should deploy to.
          folder: build # The folder the action should deploy.
          target-folder: ''
          clean: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
